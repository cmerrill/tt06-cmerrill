/* Generated by Amaranth Yosys 0.35 (PyPI ver 0.35.0.0.post81, git sha1 cc31c6ebc) */

(* top =  1  *)
(* generator = "Amaranth" *)
module tt_um_cmerrill_pdm(uo_out, uio_in, uio_out, uio_oe, ena, clk, rst_n, ui_in);
  reg \$auto$verilog_backend.cc:2189:dump_module$1  = 0;
  wire [9:0] \$11 ;
  wire [8:0] \$12 ;
  wire [9:0] \$14 ;
  wire \$2 ;
  wire \$4 ;
  wire [4:0] \$6 ;
  wire [4:0] \$7 ;
  wire \$9 ;
  input clk;
  wire clk;
  wire \clk$1 ;
  wire [3:0] clock_div;
  reg [3:0] clock_div_counter = 4'h0;
  reg [3:0] \clock_div_counter$next ;
  wire cs_edge_detect_inp;
  wire cs_edge_detect_out;
  input ena;
  wire ena;
  wire [7:0] pdm_data_in;
  reg pdm_divided_clock_pulse = 1'h0;
  reg \pdm_divided_clock_pulse$next ;
  wire pdm_pdm_out;
  wire [7:0] pfm1_data_in;
  wire pfm1_pfm_out;
  wire [7:0] pfm2_data_in;
  wire pfm2_pfm_out;
  wire [7:0] pwm_data_in;
  wire pwm_pwm_out;
  wire rst;
  input rst_n;
  wire rst_n;
  wire spi_cs_l;
  wire spi_cs_out;
  wire [7:0] spi_dout;
  wire spi_rst;
  wire spi_sclk;
  wire spi_sdi;
  input [7:0] ui_in;
  wire [7:0] ui_in;
  reg [7:0] ui_in_sel = 8'h00;
  reg [7:0] \ui_in_sel$next ;
  reg [7:0] ui_in_sel_mux;
  input [7:0] uio_in;
  wire [7:0] uio_in;
  output [7:0] uio_oe;
  wire [7:0] uio_oe;
  output [7:0] uio_out;
  wire [7:0] uio_out;
  output [7:0] uo_out;
  wire [7:0] uo_out;
  assign \$9  = clock_div_counter >= clock_div;
  assign \$12  = + ui_in_sel;
  assign \$14  = $signed(\$12 ) - $signed(9'h180);
  always @(posedge \clk$1 )
    ui_in_sel <= \ui_in_sel$next ;
  always @(posedge \clk$1 )
    clock_div_counter <= \clock_div_counter$next ;
  always @(posedge \clk$1 )
    pdm_divided_clock_pulse <= \pdm_divided_clock_pulse$next ;
  assign \$2  = ~ rst_n;
  assign \$4  = clock_div_counter >= clock_div;
  assign \$7  = clock_div_counter + 1'h1;
  \tt_um_cmerrill_pdm.cs_edge_detect  cs_edge_detect (
    .clk(\clk$1 ),
    .inp(cs_edge_detect_inp),
    .out(cs_edge_detect_out),
    .rst(rst)
  );
  \tt_um_cmerrill_pdm.pdm  pdm (
    .clk(\clk$1 ),
    .data_in(pdm_data_in),
    .divided_clock_pulse(pdm_divided_clock_pulse),
    .pdm_out(pdm_pdm_out),
    .rst(rst)
  );
  \tt_um_cmerrill_pdm.pfm1  pfm1 (
    .clk(\clk$1 ),
    .data_in(pfm1_data_in),
    .divided_clock_pulse(pdm_divided_clock_pulse),
    .pfm_out(pfm1_pfm_out),
    .rst(rst)
  );
  \tt_um_cmerrill_pdm.pfm2  pfm2 (
    .clk(\clk$1 ),
    .data_in(pfm2_data_in),
    .divided_clock_pulse(pdm_divided_clock_pulse),
    .pfm_out(pfm2_pfm_out),
    .rst(rst)
  );
  \tt_um_cmerrill_pdm.pwm  pwm (
    .clk(\clk$1 ),
    .data_in(pwm_data_in),
    .divided_clock_pulse(pdm_divided_clock_pulse),
    .pwm_out(pwm_pwm_out),
    .rst(rst)
  );
  \tt_um_cmerrill_pdm.spi  spi (
    .clk(\clk$1 ),
    .cs_l(spi_cs_l),
    .cs_out(spi_cs_out),
    .dout(spi_dout),
    .rst(rst),
    .\rst$1 (spi_rst),
    .sclk(spi_sclk),
    .sdi(spi_sdi)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$1 ) begin end
    (* full_case = 32'd1 *)
    casez (uio_in[7])
      1'h0:
          ui_in_sel_mux = ui_in;
      1'h1:
          ui_in_sel_mux = spi_dout;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$1 ) begin end
    \ui_in_sel$next  = ui_in_sel;
    casez (cs_edge_detect_out)
      1'h1:
          \ui_in_sel$next  = ui_in_sel_mux;
    endcase
    casez (rst)
      1'h1:
          \ui_in_sel$next  = 8'h00;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$1 ) begin end
    (* full_case = 32'd1 *)
    casez (\$4 )
      1'h1:
          \clock_div_counter$next  = 4'h0;
      default:
          \clock_div_counter$next  = \$7 [3:0];
    endcase
    casez (rst)
      1'h1:
          \clock_div_counter$next  = 4'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$1 ) begin end
    (* full_case = 32'd1 *)
    casez (\$9 )
      1'h1:
          \pdm_divided_clock_pulse$next  = 1'h1;
      default:
          \pdm_divided_clock_pulse$next  = 1'h0;
    endcase
    casez (rst)
      1'h1:
          \pdm_divided_clock_pulse$next  = 1'h0;
    endcase
  end
  assign \$6  = \$7 ;
  assign \$11  = \$14 ;
  assign pfm2_data_in = ui_in_sel;
  assign pfm1_data_in = ui_in_sel;
  assign pwm_data_in = ui_in_sel;
  assign pdm_data_in = \$14 [7:0];
  assign clock_div = uio_in[3:0];
  assign cs_edge_detect_inp = spi_cs_out;
  assign spi_sdi = uio_in[6];
  assign spi_sclk = uio_in[5];
  assign spi_cs_l = uio_in[4];
  assign spi_rst = rst;
  assign uo_out[3] = pfm2_pfm_out;
  assign uo_out[2] = pfm1_pfm_out;
  assign uo_out[4] = pwm_pwm_out;
  assign uo_out[0] = pdm_pdm_out;
  assign { uo_out[7:5], uo_out[1] } = 4'h0;
  assign uio_out = 8'h00;
  assign uio_oe = 8'h00;
  assign rst = \$2 ;
  assign \clk$1  = clk;
endmodule

(* generator = "Amaranth" *)
module \tt_um_cmerrill_pdm.cs_edge_detect (rst, inp, out, clk);
  reg \$auto$verilog_backend.cc:2189:dump_module$2  = 0;
  wire \$1 ;
  wire \$3 ;
  input clk;
  wire clk;
  input inp;
  wire inp;
  reg input_buf = 1'h0;
  reg \input_buf$next ;
  output out;
  wire out;
  input rst;
  wire rst;
  assign \$1  = ~ input_buf;
  assign \$3  = \$1  & inp;
  always @(posedge clk)
    input_buf <= \input_buf$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$2 ) begin end
    \input_buf$next  = inp;
    casez (rst)
      1'h1:
          \input_buf$next  = 1'h0;
    endcase
  end
  assign out = \$3 ;
endmodule

(* generator = "Amaranth" *)
module \tt_um_cmerrill_pdm.pdm (rst, divided_clock_pulse, data_in, pdm_out, clk);
  reg \$auto$verilog_backend.cc:2189:dump_module$3  = 0;
  wire [9:0] \$1 ;
  wire \$10 ;
  wire \$12 ;
  wire [8:0] \$2 ;
  wire [9:0] \$4 ;
  wire \$6 ;
  wire \$8 ;
  input clk;
  wire clk;
  input [7:0] data_in;
  wire [7:0] data_in;
  reg [7:0] data_out;
  input divided_clock_pulse;
  wire divided_clock_pulse;
  reg [8:0] error = 9'h000;
  reg [8:0] \error$next ;
  reg [7:0] error_out;
  output pdm_out;
  reg pdm_out = 1'h0;
  reg \pdm_out$next ;
  input rst;
  wire rst;
  assign \$10  = $signed(error_out) >= $signed(8'h00);
  assign \$12  = $signed(error_out) >= $signed(8'h00);
  always @(posedge clk)
    error <= \error$next ;
  always @(posedge clk)
    pdm_out <= \pdm_out$next ;
  assign \$2  = $signed(error_out) - $signed(data_out);
  assign \$4  = $signed(data_in) + $signed(\$2 );
  assign \$6  = $signed(error) > $signed(9'h07f);
  assign \$8  = $signed(error) < $signed(8'h80);
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$3 ) begin end
    \error$next  = \$4 [8:0];
    casez (divided_clock_pulse)
      1'h0:
          \error$next  = error;
    endcase
    casez (rst)
      1'h1:
          \error$next  = 9'h000;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$3 ) begin end
    (* full_case = 32'd1 *)
    casez ({ \$8 , \$6  })
      2'b?1:
          error_out = 8'h7f;
      2'b1?:
          error_out = 8'h80;
      default:
          error_out = error[7:0];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$3 ) begin end
    (* full_case = 32'd1 *)
    casez (\$10 )
      1'h1:
          data_out = 8'h7f;
      default:
          data_out = 8'h80;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$3 ) begin end
    (* full_case = 32'd1 *)
    casez (\$12 )
      1'h1:
          \pdm_out$next  = 1'h1;
      default:
          \pdm_out$next  = 1'h0;
    endcase
    casez (divided_clock_pulse)
      1'h0:
          \pdm_out$next  = pdm_out;
    endcase
    casez (rst)
      1'h1:
          \pdm_out$next  = 1'h0;
    endcase
  end
  assign \$1  = \$4 ;
endmodule

(* generator = "Amaranth" *)
module \tt_um_cmerrill_pdm.pfm1 (rst, divided_clock_pulse, data_in, pfm_out, clk);
  reg \$auto$verilog_backend.cc:2189:dump_module$4  = 0;
  wire [8:0] \$1 ;
  wire \$10 ;
  wire [8:0] \$12 ;
  wire \$14 ;
  wire \$16 ;
  wire \$18 ;
  wire [8:0] \$2 ;
  wire [9:0] \$20 ;
  wire [9:0] \$21 ;
  wire [8:0] \$4 ;
  wire \$6 ;
  wire \$8 ;
  input clk;
  wire clk;
  input [7:0] data_in;
  wire [7:0] data_in;
  input divided_clock_pulse;
  wire divided_clock_pulse;
  reg [8:0] pfm_counter = 9'h000;
  reg [8:0] \pfm_counter$next ;
  wire [7:0] pfm_in;
  output pfm_out;
  reg pfm_out = 1'h0;
  reg \pfm_out$next ;
  input rst;
  wire rst;
  assign \$10  = \$6  & \$8 ;
  assign \$14  = \$12  >= pfm_in;
  assign \$18  = \$14  & \$16 ;
  assign \$21  = pfm_counter + 1'h1;
  always @(posedge clk)
    pfm_out <= \pfm_out$next ;
  always @(posedge clk)
    pfm_counter <= \pfm_counter$next ;
  assign \$2  = 8'hff - data_in;
  assign \$6  = \$4  >= pfm_in;
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$4 ) begin end
    (* full_case = 32'd1 *)
    casez (\$10 )
      1'h1:
          \pfm_out$next  = 1'h1;
      default:
          \pfm_out$next  = 1'h0;
    endcase
    casez (divided_clock_pulse)
      1'h0:
          \pfm_out$next  = pfm_out;
    endcase
    casez (rst)
      1'h1:
          \pfm_out$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$4 ) begin end
    (* full_case = 32'd1 *)
    casez (\$18 )
      1'h1:
          \pfm_counter$next  = 9'h000;
      default:
          \pfm_counter$next  = \$21 [8:0];
    endcase
    casez (divided_clock_pulse)
      1'h0:
          \pfm_counter$next  = pfm_counter;
    endcase
    casez (rst)
      1'h1:
          \pfm_counter$next  = 9'h000;
    endcase
  end
  assign \$1  = \$2 ;
  assign \$20  = \$21 ;
  assign pfm_in = \$2 [7:0];
  assign \$4  = { 1'h0, pfm_counter[8:1] };
  assign \$8  = pfm_counter[0];
  assign \$12  = { 1'h0, pfm_counter[8:1] };
  assign \$16  = pfm_counter[0];
endmodule

(* generator = "Amaranth" *)
module \tt_um_cmerrill_pdm.pfm2 (rst, divided_clock_pulse, data_in, pfm_out, clk);
  reg \$auto$verilog_backend.cc:2189:dump_module$5  = 0;
  wire [9:0] \$1 ;
  wire \$10 ;
  wire [9:0] \$12 ;
  wire [9:0] \$13 ;
  wire [8:0] \$2 ;
  wire [9:0] \$4 ;
  wire [8:0] \$6 ;
  wire \$8 ;
  input clk;
  wire clk;
  input [7:0] data_in;
  wire [7:0] data_in;
  input divided_clock_pulse;
  wire divided_clock_pulse;
  reg [8:0] pfm2_counter = 9'h000;
  reg [8:0] \pfm2_counter$next ;
  wire [8:0] pfm2_in;
  output pfm_out;
  reg pfm_out = 1'h0;
  reg \pfm_out$next ;
  input rst;
  wire rst;
  assign \$10  = pfm2_counter > pfm2_in;
  assign \$13  = pfm2_counter + 1'h1;
  always @(posedge clk)
    pfm_out <= \pfm_out$next ;
  always @(posedge clk)
    pfm2_counter <= \pfm2_counter$next ;
  assign \$2  = 8'hff - data_in;
  assign \$8  = pfm2_counter >= \$6 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$5 ) begin end
    (* full_case = 32'd1 *)
    casez (\$8 )
      1'h1:
          \pfm_out$next  = 1'h1;
      default:
          \pfm_out$next  = 1'h0;
    endcase
    casez (divided_clock_pulse)
      1'h0:
          \pfm_out$next  = pfm_out;
    endcase
    casez (rst)
      1'h1:
          \pfm_out$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$5 ) begin end
    (* full_case = 32'd1 *)
    casez (\$10 )
      1'h1:
          \pfm2_counter$next  = 9'h000;
      default:
          \pfm2_counter$next  = \$13 [8:0];
    endcase
    casez (divided_clock_pulse)
      1'h0:
          \pfm2_counter$next  = pfm2_counter;
    endcase
    casez (rst)
      1'h1:
          \pfm2_counter$next  = 9'h000;
    endcase
  end
  assign \$1  = \$4 ;
  assign \$12  = \$13 ;
  assign pfm2_in = \$4 [8:0];
  assign \$4  = { \$2 , 1'h0 };
  assign \$6  = { 1'h0, \$4 [8:1] };
endmodule

(* generator = "Amaranth" *)
module \tt_um_cmerrill_pdm.pwm (rst, divided_clock_pulse, data_in, pwm_out, clk);
  reg \$auto$verilog_backend.cc:2189:dump_module$6  = 0;
  wire \$1 ;
  wire \$3 ;
  wire [8:0] \$5 ;
  wire [8:0] \$6 ;
  input clk;
  wire clk;
  reg [7:0] data_buffer = 8'h00;
  reg [7:0] \data_buffer$next ;
  input [7:0] data_in;
  wire [7:0] data_in;
  input divided_clock_pulse;
  wire divided_clock_pulse;
  reg [7:0] pwm_counter = 8'h00;
  reg [7:0] \pwm_counter$next ;
  output pwm_out;
  reg pwm_out = 1'h0;
  reg \pwm_out$next ;
  input rst;
  wire rst;
  always @(posedge clk)
    pwm_counter <= \pwm_counter$next ;
  assign \$1  = ! pwm_counter;
  assign \$3  = pwm_counter <= data_buffer;
  assign \$6  = pwm_counter + 1'h1;
  always @(posedge clk)
    data_buffer <= \data_buffer$next ;
  always @(posedge clk)
    pwm_out <= \pwm_out$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$6 ) begin end
    \data_buffer$next  = data_buffer;
    casez (\$1 )
      1'h1:
          \data_buffer$next  = data_in;
    endcase
    casez (divided_clock_pulse)
      1'h0:
          \data_buffer$next  = data_buffer;
    endcase
    casez (rst)
      1'h1:
          \data_buffer$next  = 8'h00;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$6 ) begin end
    (* full_case = 32'd1 *)
    casez (\$3 )
      1'h1:
          \pwm_out$next  = 1'h1;
      default:
          \pwm_out$next  = 1'h0;
    endcase
    casez (divided_clock_pulse)
      1'h0:
          \pwm_out$next  = pwm_out;
    endcase
    casez (rst)
      1'h1:
          \pwm_out$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$6 ) begin end
    \pwm_counter$next  = \$6 [7:0];
    casez (divided_clock_pulse)
      1'h0:
          \pwm_counter$next  = pwm_counter;
    endcase
    casez (rst)
      1'h1:
          \pwm_counter$next  = 8'h00;
    endcase
  end
  assign \$5  = \$6 ;
endmodule

(* generator = "Amaranth" *)
module \tt_um_cmerrill_pdm.spi (rst, \rst$1 , cs_l, sclk, sdi, cs_out, dout, clk);
  reg \$auto$verilog_backend.cc:2189:dump_module$7  = 0;
  wire \$2 ;
  input clk;
  wire clk;
  input cs_l;
  wire cs_l;
  output cs_out;
  wire cs_out;
  output [7:0] dout;
  wire [7:0] dout;
  input rst;
  wire rst;
  input \rst$1 ;
  wire \rst$1 ;
  input sclk;
  wire sclk;
  input sdi;
  wire sdi;
  wire spi_clk;
  reg [7:0] spi_data_cdc_spi_data_live = 8'h00;
  reg [7:0] \spi_data_cdc_spi_data_live$next ;
  wire spi_rst;
  assign \$2  = ~ cs_l;
  always @(posedge spi_clk, posedge spi_rst)
    if (spi_rst) spi_data_cdc_spi_data_live <= 8'h00;
    else spi_data_cdc_spi_data_live <= \spi_data_cdc_spi_data_live$next ;
  \tt_um_cmerrill_pdm.spi.spi_cs_cdc  spi_cs_cdc (
    .clk(clk),
    .cs_l(cs_l),
    .cs_out(cs_out),
    .rst(rst)
  );
  \tt_um_cmerrill_pdm.spi.spi_data_cdc  spi_data_cdc (
    .clk(clk),
    .dout(dout),
    .rst(rst),
    .spi_data_live(spi_data_cdc_spi_data_live)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$7 ) begin end
    \spi_data_cdc_spi_data_live$next  = spi_data_cdc_spi_data_live;
    casez (\$2 )
      1'h1:
        begin
          \spi_data_cdc_spi_data_live$next [7:1] = spi_data_cdc_spi_data_live[6:0];
          \spi_data_cdc_spi_data_live$next [0] = sdi;
        end
    endcase
    casez (spi_rst)
      1'h1:
          \spi_data_cdc_spi_data_live$next  = 8'h00;
    endcase
  end
  assign spi_rst = \rst$1 ;
  assign spi_clk = sclk;
endmodule

(* generator = "Amaranth" *)
module \tt_um_cmerrill_pdm.spi.spi_cs_cdc (rst, cs_l, cs_out, clk);
  reg \$auto$verilog_backend.cc:2189:dump_module$8  = 0;
  input clk;
  wire clk;
  input cs_l;
  wire cs_l;
  output cs_out;
  wire cs_out;
  input rst;
  wire rst;
  reg stage0 = 1'h0;
  reg \stage0$next ;
  reg stage1 = 1'h0;
  reg \stage1$next ;
  always @(posedge clk)
    stage0 <= \stage0$next ;
  always @(posedge clk)
    stage1 <= \stage1$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$8 ) begin end
    \stage0$next  = cs_l;
    casez (rst)
      1'h1:
          \stage0$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$8 ) begin end
    \stage1$next  = stage0;
    casez (rst)
      1'h1:
          \stage1$next  = 1'h0;
    endcase
  end
  assign cs_out = stage1;
endmodule

(* generator = "Amaranth" *)
module \tt_um_cmerrill_pdm.spi.spi_data_cdc (rst, dout, spi_data_live, clk);
  reg \$auto$verilog_backend.cc:2189:dump_module$9  = 0;
  input clk;
  wire clk;
  output [7:0] dout;
  wire [7:0] dout;
  input rst;
  wire rst;
  input [7:0] spi_data_live;
  wire [7:0] spi_data_live;
  reg [7:0] stage0 = 8'h00;
  reg [7:0] \stage0$next ;
  reg [7:0] stage1 = 8'h00;
  reg [7:0] \stage1$next ;
  always @(posedge clk)
    stage0 <= \stage0$next ;
  always @(posedge clk)
    stage1 <= \stage1$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$9 ) begin end
    \stage0$next  = spi_data_live;
    casez (rst)
      1'h1:
          \stage0$next  = 8'h00;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2189:dump_module$9 ) begin end
    \stage1$next  = stage0;
    casez (rst)
      1'h1:
          \stage1$next  = 8'h00;
    endcase
  end
  assign dout = stage1;
endmodule
